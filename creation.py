print(
'''
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⣶⣶⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣤⣤⣄⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⡿⠟⠋⠁⠀⠀⠀⠀⠀⠈⠉⠛⠦⣄⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢠⡼⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢦⣶⣶⣶⣦⣄⠀
⠀⠀⠀⠀⠀⠀⠀⢠⡟⠀⠀⠀⠀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⣿⣿⣿⣦
⠀⢀⣀⣀⡀⠀⠀⡿⠀⠀⢀⣴⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⡟
⢀⣿⣿⣿⣿⣦⣄⡇⠈⠋⢸⣿⣿⣯⣼⠏⠀⠀⠀⠀⠀⢀⣰⣦⣄⠀⠀⠀⠀⢹⡿⠋⠀
⠈⣿⣿⣿⣿⣿⣿⣿⠀⠀⢀⣙⠛⠛⠁⠀⠀⣦⣤⡀⠀⣾⡟⣿⣿⣷⠀⠀⠀⢸⠂⠀⠀
⠀⠹⣿⣿⣿⣿⣿⣿⣧⡀⠉⠁⠀⠀⠀⠻⣤⣿⣉⣩⠀⠹⣷⣿⣿⡿⠀⠀⠀⣼⠀⠀⠀
⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣶⣄⡀⠀⠀⠀⠀⠈⠉⠁⠀⠀⢨⡉⠉⠀⢸⠀⣼⠃⠀⠀⠀
⠀⠀⠀⠈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣄⣀⠀⠀⠀⠀⠀⠀⠑⠆⠀⣠⡾⠁⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠙⡟⠛⠻⠿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⣶⣶⣿⣏⠁⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⠀⠀⠉⠛⠛⠿⢿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢸⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⣿⣿⣷⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣿⣿⠈⠙⠛⠉⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⡗⠒⠶⠤⠤⣶⣶⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠙⠿⠿⠿⠃⠀⠀⠀⠀⠀⠀⠙⠿⠿⠟⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
'''
)


#-->creation of empty dataframe
'''
import pandas as pd
S=pd.DataFrame()
print(S)
'''


#-->Creation of Dataframe from Numpy Pandas
'''
import pandas as pd
import numpy as np
a1=np.array([11,12,13,14,15])
S=pd.DataFrame(a1)
print(S)
'''


#--> Creating DataFrame using Dict
'''
import pandas as pd
import numpy as np
a1=np.array([11,12,13,14,15])
a2=np.array(["A","B","C","D","E"])
Dict = {
"Section": a2,"Number of students": a1
}
S=pd.DataFrame(Dict) 
print(S)
#accesing the individual values:
print(f"your search result is: {S["Section"][1]}")
'''



#--> Using list in palce of Dict 
'''
import pandas as pd
import numpy as np
a1=np.array([11,12,13,14,15])
a2=np.array(["A","B","C","D","E"])
l1=[a2,a1]
S=pd.DataFrame(l1,index=["Section","No. of students"],columns=["d1","d2","d3","d4","d5"]) 
print(S)
#accesing the individual values:
print(f"your search result is: {S['d4']['No. of students']}")
'''



#creating a dataframe from list of dictionaries
'''
import pandas as pd
D1={"Roll_No":1,"Class":12,"Section":"A","Name":"Ananya"}
D2={"Roll_No":15,"Class":12,"Section":"B","Name":"Siddhart"}
D3={"Roll_No":10,"Class":12,"Section":"D","Name":"Ramanya","Marks":13}
l1=[D1,D2,D3]
S=pd.DataFrame(l1)
print(S)

'''

#creating a dataframe from Dictionary of List
'''
import pandas as pd
Name=["yash","Sammer","vani"]
Class=["10th","12th","9th"]
Marks=[50,60,45]
data={
    "Name": Name,
    "Class": Class,
    "Marks": Marks
}
S=pd.DataFrame(data,)
print(S)
'''


#Creation of dataframe from list of series:
'''
import pandas as pd
Name=pd.Series(["yash","Sammer","vani"])
Class=pd.Series(["10th","12th","9th"])
Marks=pd.Series([50,60,45])
data={
    "Name": Name,
    "Class": Class,
    "Marks": Marks
}
S=pd.DataFrame(data,)
print(S)
'''



#Creating a dataframe form Dictionary of Dictionary:
'''
import pandas as pd
D1={"Name": "Ankit","Age":22, "Grade":"A+"}
D2={"Name": "Titu","Age":-9, "Grade":"Z"}
D3={"Name": "Sonu","Age":555, "Grade":"C"}
Data={
    "Marketing": D1,
    "Sports": D2,
    "Swimming":D3
}
S=pd.DataFrame(Data)
print(S)
'''

#DataFrame Attributes 
'''
index--> return only index names
columns--> return column names
axes--> retrun row and column both
dtypes--> return column wise datatype
size--> return no. of R * No. of C
shape--> gives result in tuple (row,column)
values--> return values only
empty--> return true when database is empty
ndim--> return dimension
T--> transpose attribute 
'''

#Loc and Iloc
'''
.loc[] is used to access a group of rows and columns by labels or a boolean array. It is label-based, meaning you need to use the exact row and column labels (names) to access the data.
Eg .... import pandas as pd
        data = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],
        'Age': [25, 30, 35, 40]}
        df = pd.DataFrame(data, index=['A', 'B', 'C', 'D'])

        # Access a specific value by row and column labels
        value = df.loc['B', 'Age']
        print(value)  # Output: 30


.iloc[] is used to access a group of rows and columns by integer positions (like standard Python indexing). It is position-based, meaning you use the index numbers (not the labels) to access data.

Eg...import pandas as pd
    data = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],
            'Age': [25, 30, 35, 40]}
    df = pd.DataFrame(data, index=['A', 'B', 'C', 'D'])

    # Access a specific value by row and column index positions
    value = df.iloc[1, 1]  # Row index 1 (second row), Column index 1 (second column)
    print(value)  # Output: 30

'''


'''
import pandas as pd
Name=["yash","Sammer","vani","Sani","Caleb","Sameer"]
Class=["10th","12th","9th","8th","10th","12th"]
Marks=[50,60,45,60,56,55]
data={
    "Name": Name,
    "Class": Class,
    "Marks": Marks
}
S=pd.DataFrame(data,index=["r1","r2","r3","r4","r5","r6"])
S1=pd.DataFrame(data)
#print(S)
#print(S.Name["r3"])
#print(S.loc[["r3","r6"]])
#print(S.loc[["r4","r5"],["Class","Marks"]])
#Slicing in this last value is included
#print(S.loc[0::-2])
#print(S.loc[::2,["Name","Marks"]])
#print(S.loc[["r4","r5"],["Class","Marks"]])
#iloc not include the last value given
#print(S1.iloc[0:,0:])
'''

# .at and .iat
'''
.at[] is used for accessing a single scalar value in a DataFrame or Series using row and column labels. It is similar to .loc[], but optimized for accessing a single value.

.iat[] is used for accessing a single scalar value in a DataFrame or Series using integer positions (similar to .iloc[]). It is optimized for accessing a single value.
'''


'''
import pandas as pd
data = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],
        'Age': [25, 30, 35, 40]}
df = pd.DataFrame(data, index=['A', 'B', 'C', 'D'])
df1 = pd.DataFrame(data, index=['A', 'B', 'C', 'D'])
print(df.at["B","Age"])
print(df1.iat[1,1])
'''

'''
Limitation of at  and iat:

.loc[] and .iloc[]:

Strengths: Flexibility, supports slicing, works well with MultiIndex, can handle lists and arrays.
Weaknesses: Slightly slower for single-element access or modification.

.at[] and .iat[]:

Strengths: Optimized for single-element access or modification, faster in performance-critical scenarios.
Weaknesses: Limited to single-element access, no slicing, less intuitive with MultiIndex, cannot handle lists or arrays.

When to Use Which:

Use .loc[] and .iloc[] when you need to work with multiple rows, columns, or slices of data, or when you’re working with complex data structures like MultiIndex.
Use .at[] and .iat[] when you need to quickly access or modify a single element, especially in performance-sensitive situations.
'''


#Boolean Indexing in pandas
'''
Definition: Boolean indexing allows filtering and manipulating data in pandas based on conditions.

Combine conditions for complex filters.
Boolean indexing is efficient for filtering and selecting data based on conditions.
'''

'''
import pandas as pd

data = {'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],
        'Age': [25, 30, 35, 40, 29],
        'City': ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix']}
df = pd.DataFrame(data)

# Filter for people older than 30 who live in Chicago or Phoenix
filtered_df = df[(df['Age'] >= 30) ]
print(df.loc[:,"Age"]>10)
print(filtered_df)

'''

#Filter Rows in DataFrame:-

'''
import pandas as pd

data = {'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],
        'Age': [25, 30, 35, 40, 29],
        'City': ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix']}
df = pd.DataFrame(data)

# Filter rows where Age > 30 and City is either Chicago or Phoenix
filtered_df = df[(df['Age'] > 30) & (df['City'].isin(['Chicago', 'Phoenix']))]
print(filtered_df)
'''

#Access and modify single cell value:

'''
import pandas as pd
data = {'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],
        'Age': [25, 30, 35, 40, 29],
        'City': ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix']}
df = pd.DataFrame(data,index=["r1","r2","r3","r4","r5"])
print(df.loc["r4","Name"])
print(df.iloc[3,0])
print(df.at["r4","Name"])
print(df.iat[3,0])
df.Name["r4"]="Honda"
print(df.loc["r4","Name"])
'''

#Modifying & Adding a New Column to a DataFrame


'''
import pandas as pd
import numpy as np
data = {'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],
        'Age': [25, 30, 35, 40, 29],
        'City': ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix']}
df = pd.DataFrame(data)

# Adding a new column with a constant value
df['Country'] = ['USA', 'SYDNEY', 'ARGENTINA', 'INDIA', 'AFRICA']

# Adding a column based on existing columns
df['Age_in_5_years'] = df['Age'] + 5

# Modifying an existing column
df['City'] = df['City'].str.upper()

# Adding a column with conditional values
df['Category'] = np.where(df['Age'] > 30, 'Senior', 'Junior')

#Another Method
df.loc[:,"Status"]=np.where(df["Category"]=="Senior",True,False)

#Assign method
#df=df.assign(Emp_ID=11025)
df.insert(2,"Emp_id",[100,101,102,103,104])
print(df)
'''

#Modifying & Adding a New Row to a DataFrame

'''
import pandas as pd

# Sample DataFrame
data = {'Name': ['Alice', 'Bob', 'Charlie'],
        'Age': [25, 30, 35],
        'City': ['New York', 'Los Angeles', 'Chicago']}
df = pd.DataFrame(data)

# 1. Adding a new row using loc[]
df.loc[3] = ['David', 40, 'Houston']

# 2. Adding a new row using append()
new_row = {'Name': 'Eve', 'Age': 29, 'City': 'Phoenix'}
df = df._append(new_row, ignore_index=True)

# 3. Adding a new row using concat()
new_row_df = pd.DataFrame([['Frank', 32, 'Miami']], columns=['Name', 'Age', 'City'])
df = pd.concat([df, new_row_df], ignore_index=True)

print(df)

'''


#deleting row and column + renameing row and column 

'''
import pandas as pd

# Sample DataFrame
data = {'Name': ['Alice', 'Bob', 'Charlie'],
        'Age': [25, 30, 35],
        'City': ['New York', 'Los Angeles', 'Chicago']}
df = pd.DataFrame(data)

# 1. Adding a new row using loc[]
df.loc[3] = ['David', 40, 'Houston']

# 2. Adding a new row using append()
new_row = {'Name': 'Eve', 'Age': 29, 'City': 'Phoenix'}
df = df._append(new_row, ignore_index=True)

# 3. Adding a new row using concat()
new_row_df = pd.DataFrame([['Frank', 32, 'Miami']], columns=['Name', 'Age', 'City'])
df = pd.concat([df, new_row_df], ignore_index=True)

#--------------------------------------------------------#

# Deleting a row by index
df = df.drop(3)  # Drop the row with index 3 (David)

# Deleting a column by name
df = df.drop(columns=['Age'])  # Drop the 'Age' column
#df.drop("Name",axis=1,inplace=True)

# Renaming a column
df = df.rename(columns={'Name': 'Full_Name'})  # Rename 'Name' column to 'Full_Name'

# Renaming a row index
df = df.rename(index={2: 'Second'})  # Rename the row index 2 to 'Second'

print(df)
'''

#Joining, Merging & Concatenation of DataFrames

'''
merge(): Joins DataFrames based on a common column or index.
Types: inner, left, right, outer.
concat(): Concatenates DataFrames along rows or columns.
axis=0 for rows, axis=1 for columns.
join(): Joins DataFrames on their indices.
Types: inner, left, right, outer.
append(): Adds rows from another DataFrame or Series to the end of the DataFrame.
- **`ignore_index`**: Creates a new sequential index for the resulting DataFrame, ignoring the original indices.
- **`verify_integrity`**: Ensures no duplicate indices in the resulting DataFrame; raises an error if duplicates are found.
- **`sort`**: Sorts the columns alphabetically before appending or concatenating.
'''

import pandas as pd
df1 = pd.DataFrame({'Key': ['A', 'B', 'C', 'D'], 'Value1': [1, 2, 3, 4]})
df2 = pd.DataFrame({'Key': ['B', 'D', 'E', 'F'], 'Value2': [5, 6, 7, 8]})

# 1. Using merge() with different join types
inner_join = pd.merge(df1, df2, on='Key', how='inner')
left_join = pd.merge(df1, df2, on='Key', how='left')
right_join = pd.merge(df1, df2, on='Key', how='right')
outer_join = pd.merge(df1, df2, on='Key', how='outer')

# 2. Using concat() to concatenate along rows and columns
concat_rows = pd.concat([df1, df2], axis=0, ignore_index=True)
concat_columns = pd.concat([df1, df2], axis=1)

# 3. Using join() to join on indices
df1_indexed = df1.set_index('Key')
df2_indexed = df2.set_index('Key')
index_join = df1_indexed.join(df2_indexed, how='inner')

# 4. Using append() to add rows to the DataFrame
appended_df = df1._append(df2,verify_integrity=True, ignore_index=True, sort=True)

# Print results
print("Inner Join:\n", inner_join)
print("\nLeft Join:\n", left_join)
print("\nRight Join:\n", right_join)
print("\nOuter Join:\n", outer_join)
print("\nConcatenated Rows:\n", concat_rows)
print("\nConcatenated Columns:\n", concat_columns)
print("\nIndex Join:\n", index_join)
print("\nAppended DataFrame:\n", appended_df)
